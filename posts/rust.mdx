---
title: [Rust] 기본 타입
slug: rust
writer: kang1027
tags: rust
image: https://images.unsplash.com/photo-1699885960867-56d5f5262d38
releaseDate: 2024.05.13
---

이번 포스트에서는 Rust의 기본 타입들을 알아보려고 한다. Rust는 우리가 다른 언어를 통해 배운 기본 자료형들을 포함에 Rust만의 고유한 타입들 역시 많이 있다. 이에 각 타입을 자유자재로 사용하기 위해서는 많은 복습이 필요하다.

위 표에서 Rust에서 사용하는 다양한 타입들을 간단하게 설명했다. 보자마자 어떻게 사용하는지 눈치챈 타입도 있을 것이고, 생소한 타입들도 있을 것이다.

이번 포스트에서는 `struct, enum, trait, fn, closer`를 제외한 자료형들을 먼저 소개하겠다.

## 1. 정수 타입

정수 타입은 매우 기본적인 타입으로 빠르게 소개하고 넘어가겠다.

### 1.1. 기본 정수

C언어에서 `int`는 4byte(=32bit)의 크기를 갖는다. 즉, `i32`와 같이 `(-2,147,483,648 ~ 2,147,483,647)` 의 수를 표현할 수 있다.`u32` 는 unsigned int 32의 뜻으로 `(0 ~ 4,294,967,295)` 의 수를 표현할 수 있다. `8, 16, 32, 64`와 같은 수치는 각 비트를 나타낸다. (2$^n$ 만큼 표현이 가능하다.)

### 1.2. 머신 워드

isize, usize는 머신 워드(machie word)라 불리며, 코드를 실행하는 머신의 주소 크기 값으로 `32bit, 64bit` 중 하나다. (사용중인 프로세서가 몇비트 기반 프로세서인지 확인해보면 32bit나 64bit중 하나일 것이다.)

### 1.3. 바이트

Rust는 바이트값에 `u8` 타입을 사용한다. 바이너리 파일이나 소켓에서 데이터를 읽으면 `u8` 값의 스트림이 나올 것이다. C나 C++과 달리 Rust는 문자를 수치 타입으로 보지 않는다. `char`는 `u8` 도 아니고, `u32` 도 아니다.

Rust는 수치 타입과 `char`타입을 별개로 보지만, `u8` 값을 문자형 리터럴인 바이트 리터럴로 쓸 수 있다. b’X’로 쓰면 X의 아스키 코드를 u8 값으로 쓸 수 있는 것이다. (`b’A’ == 65u8` → `true`)

### 1.4. 타입 추론

Rust는 리터럴 값에서 후보군에 `i32`가 있으면 이를 기본값으로 쓰고, 그렇지 않으면 모호하다는 오류를 낸다.

(`let a = 5;` 와 같이 코드를 작성하면 a는 i32타입을 가진다.)

### 1.5. 접두사

접두사 `0x,0o, 0b` 는 각각 16진수, 8진수, 2진수 리터럴을 지정하는데 쓰인다.

### 1.6. ‘_’ 구분자

`let num = 1234567;` 과 같이 긴 수는 ‘`_`’로 구분할 수 있다. 아래는 간단한 예시들이다.

- `let num = 1_234_567;`
- `let num = 4_294_967_295_u32;`
- `let x = 0xffff_ffff_u16;`

***

## 2. 부동소수점

Rust의 부동소수점 타입인 `f32,f64` 는 IEEE가 정의한 단정밀도와 배정밀도 타입을 지원한다.

C,C++ 등 언어의 `float,double`과 같은 역할을 한다.

***

## 3. bool

Rust의 bool 타입 역시 똑같다.

특이한 점은 Rust는 bool 값을 메모리에 표현하는데 한 바이트를 통으로 쓴다. 이에 `bool` 타입을 가르키는 포인터를 만들 수 있다.

***

## 4. 문자

Rust의 문자 타입인 char는 앞서 보았듯 유니코드 문자 하나를 `32bit`의 값으로 표현한다.

또한 개별 문자에 대해서는 `char` 타입을 쓰지만, 문자열과 텍스트 스트림에서는 UTF-8 인코딩을 쓴다. 따라서 `String`은 자신이 가진 텍스트를 문자 배열이 아니라 UTF-8 바이트 시퀀스로 표현한다.

***

## 5. 튜플

튜플은 다양한 타입의 값들을 한데 모아 묶은 것이다. 일련의 요소들을 쉼표로 구분한 다음 괄호 안에 넣으면 튜플이 된다. 예를 들어 `(“Brazil", 1985)`는 `(&str, i32)` 타입을 갖는다. 튜플 값 `t` 가 있을 때, 그 안에 있는 요소는 `t.0, t.1` 로 접근한다.

Rust에서 튜플은 배열과 별개로 취급되는데, 튜플은 각 요소의 타입이 다를 수 있지만, 배열은 모든 요소에 타입이 반드시 같아야 한다. 또한 튜플은 `t.i, t[i]` 처럼 접근할 수 없다.

유닛‘`()`’은 반환 타입으로 자주 사용된다. `Result<(), std::io::Error>` 와 같이 성공하면 아무 값도 반환하지 않고, 문제가 있을 때만 에러를 반환하는 등으로 사용한다.

***

## 6. 포인터 타입

Rust는 C, C++과 같이 메모리 주소를 표현하는 타입을 가지고 있다. 이에 가비지컬렉터 역시 없는데, 이는 메모리 효율이 좋지만 프로그램에서 다른 값을 가리키는 값이 필요할 때 명시적으로 포인터 타입을 써주어야 하는 번거로움이 있다.

Rust의 안전한 공간에서 사용되는 포인터 타입의 경우는 미정의 동작을 일으킬 수 없도록 되어 있어 C++에 비해 포인터를 올바로 사용하기 쉬울 것이다. 포인터 타입에는 래퍼런스,  박스, 안전하지 않은 포인터등이 있다.

### 6.1. 레퍼런스

`&String` 타입의 값은 `String` 값의 레퍼런스이고, `&i32` 타입의 값은 `i32` 값의 레퍼런스이다. 실행 시점에서 `&i32`는 스택이나 힙에 위치한 `i32` 주소를 쥐고 있는 **1 머신 워드 크기**의 값이다.

표현식 `&x`는 `x`의 레퍼런스를 생성하는데, Rust에서는 `x`의 레퍼런스를 빌려(borrow)온다고 표현한다. 레퍼런스 `r`이 있을 때 표현식 `*r` 은 `r`이 가리키는 값을 나타낸다. 이들은 C와 C++의 `&`(레퍼런스)와 `*`(포인터) 연산자와 매우 유사하다. 하지만 Rust의 레퍼런스는 C 포인터와 달리 `null` 값을 가질 수 없다.

또한 Rust는 값의 소유권과 슈명을 추적하기 때문에 **대상을 잃은 포인터**, **중복 해제**, **포인터 무효**와 같은 실수들이 **컴파일 시점**에 배제된다.

Rust의 레퍼런스에는 `&T`와 `&mut T`로 두 종류가 있다.

#### 6.1.1. &T

`&T`는 변경할 수 없는 공유된 레퍼런스로 같은 값을 참조하는 공유된 레퍼런스는 동시에 여러개 있을 수 있지만, 모두 **읽기 전용(readonly)**라서 C의 `const T*` 처럼 가리키는 값을 수정하는 데에는 사용할 수 없다.

#### 6.1.2. &mut T

변경할 수 있는 배타적인 레퍼런스로 C의 `const T*` 처럼 가리키는 값을 읽고 수정할 수 있지만, **이 레퍼런스가 존재하는 동안은 같은 값을 참조하는 다른 레퍼런스를 가질 수 없다.** 실제로 이 값에 접근하는 유일한 방법은 이 변경할 수 있는 레퍼런스를 통하는 것뿐이다.

이에 Rust는 **Single Writer or Multiple Reader** 규칙을 구현한다. 이 규칙은 값을 읽고 쓸 수 있는 상태가 되거나 여러 readers가 공유할 수 있는 상태가 되거나 둘 중 하나만 선택해야 한다는 규칙이다.

### 6.2. 박스 (Box)

Rust는 할당을 최소화하도록 설계되었다. 메모리 효율을 좋게 하기 위해 값을 기본적으로 끼워 맞춰 힙(heap)에

무모하게 할당하는 행동을 하지 않는다.

- 이  점이 Java와의 큰 차이라고도 볼 수 있다. Java는 OOP(Object Oriented Programming)만을 중시하는 언어로서 **모든 객체를 힙에 할당**하고 이를 **참조**(References)라는 개념으로 추적한다. (역시 유효하지 않은 메모리는 GC(Garbage Collector)가 처리한다.) 이는 프로그래머 입장에서는 직관적이고 편리한 개발이 가능하지만, 매우 느린 언어로서 자리매김한 원인이기도 하다.

이 때, BOX를 이용하면 힙에 값을 임의로 할당할 수 있다.

코드를 `let t = (12, "eggs");` 라고 입력하면 이 튜플은 힙에 저장되지 않지만, `let b = Box::new(t);` 처럼 Boxing할 시 튜플을 힙에 할당할 수 있다. 이 코드에서 `t`의 타입은 `(i32, &str)`이므로, `b`의 타입은 `Box<(i32, &str)`가 된다. `Box::new` 호출은 이 튜플을 저장하는데 필요한 힙 메모리를 할당한다. 이는 `b`가 범위를 벗어나는 즉시 해제되는데, `b`가 반환되거나 하는 등의 이유로 이동된 경우는 예외다.

### 6.3. 원시 포인터

Rust는 원시 포인터(raw pointer) 타입인 `*mut T`와 `*const T`도 가지고 있다. 이는 C++과 같은 개념이며, Rust는 원시 포인터가 가리키는 대상을 추적하지 않으므로 안전하지 않다. 원시 포인터는 `null`이 될 수도 있고, 이미 해제되었거나 다른 타입의 값으로 바뀐 메모리를 가리킬 수도 있다.

원시 포인터는 `unsafe` 블록 안에서만 사용이 가능하다. `unsafe` 블록은 개발자가 스스로 안전성을 보장한다는 전제하에 컴파일러의 추적을 일부 회피하고 언어의 고급기능을 쓸 수 있게 해주는 Rust의 옵트인(Opt-in) 메커니즘이다.

### 6.4. 배열, 벡터, 슬라이스

Rust에는 일련의 값을 메모리에 표현할 때 쓸 수 있는 타입이 세 가지 있다.

1. `[T; N]` 타입은 `T`타입의 값을 `N`개 갖는 배열을 표현한다. 배열의 크기는 컴파일 시점에 결정되는 상수로 타입의 일부다. 따라서 배열에 새 요소를 추가하거나 배열의 크기를 축소할 수 없다.
2. `Vec<T>` 타입은 동적으로 할당되고 확장될 수 있는 일련의 `T` 타입 값으로 T 벡터라고 부른다. 벡터는 요소를 전부 힙에 저장하기 때문에 새 요소를 추가하거나, 다른 벡터를 가져와 넣거나, 기존 요소를 삭제하는 등, 크기 변경이 뒤따르는 작업을 유연하게 수행할 수 있다.
3. `&[T]`와 `&mut [T]` 타입은 배열이나 벡터 같은 값의 일부분을 가리키는 레퍼런스로 각각 공유된 **T 슬라이스**와 변경할 수 있는  **T 슬라이스**라 부른다.
슬라이스는 참조 대상의 첫 번째 요소를 가리키는 포인터와 그 위치로부터 접근할 수 있는 요소의 개수를 합친 것이다. `&[T]`는 요소를 공유할 수 있지만, 읽을 수 밖에 없다. 반대로  `&mut [T]`는 요소를 읽고 수정할 수 있지만, 공유할 수 없다. 이 역시 앞서 설명한 Rust의 **Single Writer or Multiple Reader** 규칙을 따른다.

`V`가 위 타입 중 하나라면, `V.len()`, `V[i]`가 가능하다.

`V`의 길이가 0일 때 색인(index)를 가지고 접근하면 패닉(Panic)에 빠진다. `**i`는 반드시 `usize` 값**이며, 다른 정수 타입으로 색인 사용은 불가하다.

#### 6.4.1. 배열

배열 값을 작성하는 방법은 여러가지이다.

1. 일련의 값을 대괄호에 기입.

 ```rust
 let lazy_carter: [u32; 6] = [1, 2, 4, 7, 11, 16];
 let animals = ["Monkey", "Cow", "Pig"];

 assert_eq!(lazy_carter[3], 7);
 assert_eq!(animals.len(), 3);
    ```

2. `[V; N]`문법을 사용한다. (`V는 값`이고, `N은 길이`이다.)

 ```rust
 let b = [true; 10000];

 assert!(b[3]);
 assert!(b[9999]);
    ```

`[V; N]` 문법은 고정크기 버퍼를 만들 때도 쓰인다. 예를 들어 `[0u8; 1024]`는 바이트값 0으로 초기화된 1KB 짜리 버퍼이다. Rust의 배열은 컴파일 시점에 고정됨으로 `[true; n]`과 같이 사용이 불가하다. 필요 시 벡터를 사용하자.


요소의 반복 처리, 검색, 정렬, 채움, 필터링 등 배열을 다룰 때 쓰이는 유용한 메서드들은 배열이 아니라 **슬라이스의 것**이다. **Rust는 메서드를 찾을 때 암묵적으로 배열 레퍼런스를 슬라이스로 바꾸기 때문에 슬라이스 메서드를 배열에 대고 바로 호출할 수 있다.**

```rust
let mut chaos = [3, 5, 4, 1, 2];
chaos.sort();
assert_eq!(chaos, [1, 2, 3, 4, 5]);
```

이 코드에서 `sort()` 메서드는 사실 슬라이스에 정의되어 있지만, 피연산자를 레퍼런스로 받기 때문에 Rust는 암묵적으로 배열 전체를 가리키는 `&mut [i32]` 슬라이스를 생성한 뒤 이를 sort에 전달한다. 앞서 언급한 `len()` 메서드도 실은 슬라이스 메서드이다. 슬라이스에 대한 자세한 내용은 아래 슬라이스 파트에서 다룬다.

#### 6.4.2 벡터

벡터 `Vec<T>`는 크기 조절이 가능한 `T`타입 배열로 요소는 모두 힙에 할당한다. 벡터를 만드는 간단한 방법은 `vec!` 매클를 쓰는 것이다.

```rust
let mut primes = vec![2,3,5,7];
assert_eq!(primes.iter().product::<i32>(), 210);
```

벡터는 요소를 동적으로 추가할 수 있다.

```rust
primes.push(11);
primes.push(13);
assert_eq!(primes.iter().product::<i32>(), 30030);
```

아래처럼 벡터를 선언할 수도 있다.

```rust
fn new_pixel_buffer(rows: usize, cols: usize) -> Vec<u8> {
	vec![0; rows * cols]
}
```

`vec!` 매크로는 `Vec::new()`를 호출해 빈 벡터를 만들고 값을 넣는 것이다.

```rust
let mut pal = Vec::new();
pal.push("step");
pal.push("on");
pal.push("no");
pal.push("pets");
assert_eq!(pal, vec!["step", "on", "no", "pets"]);
```

또 이터레이터(Iterator)가 넘겨주는 값을 가지고 벡터를 만들 수도 있다.

```rust
let v:Vec<i32> = (0..5).collect();
assert_eq!(v, [0, 1, 2, 3, 4]);
```

- 여기서 `collect()` 메서드는 벡터뿐 아니라 다양한 종류의 컬렉션을 만들 수 있기 때문에 종종 타입을 지정해야 할 수도 있다.

슬라이스 메서드는 벡터 역시 배열과 마찬가지로 사용이 가능하다.

```rust
let mut number = vec![5, 4, 3, 2, 1];
number.reverse();
assert_eq!(number, vec![1, 2, 3, 4, 5]);
```

이 코드에서 `reverse()` 메서드는 암묵적으로 벡터에서 `&mut [i32]` 슬라이스를 빌려온 뒤 여기에 reverse를 호출한다.

`Vec<T>`는 세가지 값으로 구성되는데, **`Vec<T>`가 요소들을 담아두기 위해서 힙에 할당해 소유하는 버퍼의 포인터**, **버퍼가 저장할 수 있는 요소의 개수를 뜻하는 용량**, **버퍼가 지금 실제로 가지고 있는 요소의 개수를 뜻하는 길이** 이다.

버퍼의 용량이 다 찬 벡터에 새 요소를 추가하면, 벡터는 더 큰 버퍼를 할당한 뒤, 현재 가지고 있는 내용을 그대로 복사하고 포인터와 용량을 새 버퍼에 맞게 갱신한다음 마지막으로 기존 버퍼를 해제하는 과정을 거친다.

만일 벡터에 담아야할 요소의 개수를 안다면 `Vec::new` 대신 `Vec::with_capacity`를 호출해 버퍼 크기를 정할 수 있다. (`vec!` 매크로는 이 방법으로 만든다.) 하지만 이 역시 추정치를 초과하면 평소대로 벡터의 공간이 확장된다.

벡터의 `len()` 은 현재 가지고 있는 요소의 개수를 반환하고, `capacity()`는 재할당 없이 저장할 수 있는 요소의 개수를 반환한다.

```rust
let mut v = Vec::with_capacity(2);
assert_eq!(v.len(), 0);
assert_eq!(v.capacity(), 2);
v.push(1);
v.push(2);
assert_eq!(v.len(), 2);
v.push(3);
assert_eq!(v.len(), 3);
println!("capacity is now {}", v.capacity()); // 3 이상이 출력된다.
```

- `v.insert(3, 35);`는 3번 인덱스에 35를 삽입한다.
- `v.remove(1);`은 1번 인덱스의 값을 삭제한다.
- `v.pop();`은 마지막 요소를 제고하고 반환한다. 이때 `Option<T>` 타입으로 반환되는데, 벡터가 비어있다면 `None`, 마지막 요소가 비었다면 `Some(u)` 를 반환한다.

아래처럼 for 루프로 사용 가능하다.

아래처럼 for 루프로 사용 가능하다.

```rust
let languages: Vec<String> = std::env::args().skip(1).collect();
for l in languages {
	println!("{} : {}", l, if l.len() % 2 == 0 { "functional"} else {"imperative"});
}
```

- 이 코드를 테스트하려면 아래처럼 cargo를 호출할 때 파라미터로 값을 넣어주면 된다.
- `cargo run [‘Parameters’]`

#### 6.4.3. 슬라이스

슬라이스는 배열이나 벡터의 한 영역으로 별도의 길이지정 없이 `[T]`라 쓴다. 슬라이스는 길이 제한이 없으므로 변수에 직접 저장하거나 함수 인수로 전달할 수 없다. 또한 슬라이스는 항상 레퍼런스로 전달된다.

슬라이스 레퍼런스는 팻 포인터(fat pointer)로, **슬라이스의 첫 번째 요소를 가리키는 포인터**와 그 안에 있는 **요소의 개수로 구성되는 2워드 크기의 값**이다.

아래 코드를 통해 슬라이스의 구조를 이해해보자.

```rust
let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
let a: [f64; 4] = [0.0, 0.707, -1.0, -0.3];

let sv: &[f64] = &v; // 슬라이스
let sa: &[f64] = &a; // 슬라이스
```

마지막 두 줄에 있는 `&Vec<f64>`와 `&[f64; 4]` 레퍼런스는 Rust에 의해 데이터를 직접 가리키는 슬라이스로 자동 변환된다. 이 코드가 만들어내는 그림은 아래와 같다.

일반적인 레퍼런스는 단일 값을 가리키는 소유권이 없는 포인터인 반면, 슬라이스 레퍼런스는 메모리에 있는 연속된 여러 값을 가리키는 소유권이 없는 포인터다.

- 이 개념은 C의 포인터배열과 유사한 동작 방식을 가진다.

따라서 같은 타입으로 된 일련의 데이터를 다루면서 배열이나 벡터에 작용하는 함수를 작성하려는 경우에는 슬라이스 레퍼런스를 쓰는게 좋다. 아래처럼 구현할 수 있다.

```rust
fn print(n: &[f64]) {
	for elt in n {
		println!("{}", elt);
	}
}

print(&v);
print(&a);
print(sv);
print(sa);
```

실제 Rust에도 벡터나 배열의 것처럼 보이는 메서드들이 슬라이스에 정의된 것일 때가 많다. `sort()`와 `reverse()`도 슬라이스 타입 `[T]`의 메서드이다.

범위를 색인으로 쓰면 배열이나 벡터의 슬라이스 레퍼런스나 기존 슬라이스의 슬라이스를 얻을 수 있다.

```rust
print(&v[0..2]);  // v에서 맨 앞에 있는 두 요소를 출력
print(&a[2..]);   // a[2]부터 그 뒤의 모든 요소 출력
print(&sv[1..3]); // v[1]과 v[2] 출력
```

Rust는 일반적인 배열 접근처럼 유효성 검사를 진행한다. 데이터의 끝을 넘어서는 범위의 슬라이스를 빌리려 하면 패닉에 빠진다.

또한 슬라이스는 거의 항상 레퍼런스 뒤에 등장하므로 `&[T]`나 `&str` 같은 타입을 그냥 ‘슬라이스’ 라고 부른다.

### 6.4.4 문자열 타입

Rust는 2개의 문자열 타입을 가지고 있다. 이는 C++의 문자열 리터럴과 동적으로 생성하는 방법과 비슷하다.

- **문자열 리터럴**
문자열 리터럴은 앞뒤로 큰따옴표가 붙는다.

```rust
let speech_1 = "\"Ouch!\" said the well.\n";
let speech_2 = "Hi! \my name is DongHyeon."); // \ 기호를 통해 줄내림을 막을 수 있다.
```

Rust는 원시 문자열(raw string)을 제공한다.

```rust
let default_win_install_path = r"c:\programfiles\rust";
println!(r###"This raw string started with 'r###",
Therefore it does not end untill we reach a quote mark("")
followed immeditely by three pund sings('###'); "###);
```

- **바이트 문자열**

바이트 문자열은 접두사 `b`가 붙은 문자열 리터럴이다. 바이트 문자열은 유니코드 텍스트가 아니라 `u8` 값(즉, 1바이트)의 슬라이스이다.

```rust
let method: &[u8; 3] = b"GET";
assert_eq!(method, &[b'G', b'E', b'T']);
```

method의 타입은 `&[u8; 3]` 으로 세 개의 바이트로 구성된 배열의 레퍼런스다. 바이트 문자열은 유니코드 문자를 가질 수 없으며, 반드시 아스키와 `\xHH` 이스케이프 시퀀스로만 구성되어야 한다.

- **문자열의 메모리 구조**
Rust의 문자열은 유니코드 문자들이 차례로 배열된 것이지만, 그렇다고 해서 메모리에 `char` 배열로 저장되는 것은 아니다. 바로 가변 폭 인코딩인 `UTF-8`을써서 저장된다. 따라서 문자열에 있는 아스키 문자는 각각 한 바이트로 저장되고, 나머지 문자들은 여러 바이트를 차지한다.
아래는 문자열을 생성하는 코드와 메모리맵 그림이다.

```rust
let noodles = "noodles".to_string();
let oodles = &noodles[1..];
let poodles = "ⵙ_ⵙ";
```

`String`은 UTF-8 텍스트를 담는 버퍼를 가지고 있다. 이 버퍼는 힙에 할당되기 때문에 크기 조절이 가능하다. `noodles`는 8byte 크기의 버퍼를 가진 String으로 7byte를 사용중이다. (용량이 1 더 큰 이유는 C언어처럼 문자열의 끝은 null문자를 가지기 때문이다.)

즉, `String`은 UTF-8만 담도록 된 `Vec<u8>`이라 생각하면 쉬운데, 실제로 그렇게 구현되어 있다. `&str`(스티어, 스트링 슬라이스)는 다른 누군가가 소유한 일련의 UTF-8 텍스트를 참조하는 레퍼런스로 텍스트를 빌려온다. `oodles`는 `noodles`에 속한 텍스트를 마지막 문자까지인 6byte를 가리키는 슬라이스이다. 다른 슬라이스 레퍼런스와 마찬가지로 `&str`는 실제 데이터의 주소와 길이로 구성되는 **fat pointer**이다. `&str`는 `&[u8]`로 생각하면 된다.

문자열 리터럴은 미리 할당된 텍스트를 가리키는 `&str`로, 보통 프로그램의 머신 코드와 함께 **읽기 전용 메모리에 저장**된다. `poodles`는 7byte크기를 가지는 문자열 리터럴로, 이는 프로그램이 실행할 때 생성되고 종료할 때까지 지속된다. `&str`는 공유된 레퍼런스로 수정이 불가하다. `&mut str`타입을  쓸 수도 있지만, UTF-8을 다루는 대부분의 연산이 전체 바이트 길이를 변경할 수 있고, 슬라이스가 자신의 참조 대상을 재할당할 수도 없어서 유용하지 않다. 이럴 땐, `String`을 써서 새 문자열을 만드는 것이 좋다.

> 💡 우리는 `char` 자료형이 32bit를 가진다고 배웠다. 즉, 유니코드는 `char` 자료형을 갖는다.
`let u: char = '\u{2D59}';`
아스키 코드 역시 유니코드의 일부로 `char` 로 선언이 가능하나, 바이트 문자열로도 선언이 가능하다.
`let b: char = 'A';`
`let b_byte: u8 = b'A';`
`let b_bytes: &[u8; 1] = b"\x41";`